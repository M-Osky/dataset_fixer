#!/usr/bin/perl
use strict; use warnings;

# new_locinames   			# by M'Ã“skar
my $program_name = "new_locinames.pl";

#to extract loci names from the vcf file generated by populations (Stacks) and replace the names into a Structure input file
#the new loci names will include the scafold number and the loci position in it.

# For options, usage and other information check the help typing the name of the program version and "help" or "--h" or so...
# new_locinames_vX.pl -help


###########################################################################################################################
###############    First version. More will come with more oftions to personalice the locinames    ########################
###########################################################################################################################



#######################   PARAMETERS   #########################
# All of them can be set from the command line, check the help.

my $vcf_file = "populations.snps.vcf";
#my $vcf_file = "populations.snps.vcf";
my $str_file = "populations.structure";
#my $str_file = "populations.structure";
my $backup_tail = ".bkp";
#my $backup_tail = ".backup";
my $headers="yes";
#my $headers="yes";





#################################################################################################################
#################################################################################################################

my $backup_file = "$str_file" . "$backup_tail";

#Help!
my %arguments = map { $_ => 1 } @ARGV;
if(exists($arguments{"help"}) || exists($arguments{"--help"}) || exists($arguments{"-help"}) || exists($arguments{"-h"}) || exists($arguments{"--h"})) {
	die "\n\n\t   $program_name   Help Information\n\t-------------------------------------------------\n
	This program will replace the default locus names used by the software populations (Stacks) in the Structure file.\n
	PROBLEM: the locus names used by \"populations\" in two of its outputs are not the same.\n
	In the vcf file generated by populations (by default \"$vcf_file\") the column \"ID\" shows for each SNP:
		A number corresponding to the locus position in the catalog (unique value if --write_single_snp)
		Then the position of the SNP in the locus
		Then + or -\n
		Example: 42:36:+\n
	In population's Structure file (by default \"$str_file\") SNP names are similar from column \"ID\" in the vcf file:
		First part of the name is the catalog position of the loci
		Second part is a number equivalent to the position of the SNP in the locus (in the vcf file) minus one.\n
		Example: 20_151

	This discrepancy may be on purpose or may be an error, but in any case is not a useful name to use. 

	SOLUTION: This script will generate a new Structure file with different loci names.\n\n\tThe new loci names will be formed combining the columns \"CHROM\" and \"POS\" from the vcf file.
	Therefore each locus name will be the number of the scaffold and the position of the SNP in the scafold,
	the two numbers are not unique separately, but combined they are. It will allow afterwards to locate the SNPs in the genome
\n		Example: 1_5063021\n
	Before replacing the locus names the script will backup the original Structure file.\n\tBy default the backup will be saved as \"$backup_file\":

	USAGE:\n\tIf the default files are present in local directory and have the default names as generated by populations,\n\tjust call the program name:
\n		perl $program_name
	
	In any other circumstance you will need to specify the file paths using the flags:
		-nohead        \t->\tuse this argument to declare that your input file does not have headers/loci names.
		--str / --input\t->\tpath/name of the structure input file (default: $str_file)
		--vcf          \t->\tpath/name of the vcf file with the SNP position (default: $vcf_file)
		--bkp          \t->\ttail to add at the end of the Structure input file name to save the backup (default: $backup_tail)
		               \t  \t - alternatively you can provide a whole path to save the backup in a different location -
	
	Examples:\n
		$program_name --vcf first_run.vcf --str all_populations.str --bkp /home/backups/Run1AllSamples.str
		$program_name --input /home/refmap/$str_file --vcf /home/refmap/$vcf_file --bkp _backup nohead
		(The backup file will be saved in the same path than the structure file unless a full path and file name is given)
	\n";
}




use Getopt::Long;

GetOptions( "vcf=s" => \$vcf_file,      # --vcf
            "str=s" => \$str_file,      # --str
            "input=s" => \$str_file,    # --input
            "input=s" => \$str_file,    # --input
            "bkp=s" => \$backup_tail ); # --bkp


if(exists($arguments{"--nohead"})) { $headers = "no";}
if(exists($arguments{"-nohead"})) { $headers = "no";}
if(exists($arguments{"nohead"})) { $headers = "no";}


#################################################################################################################
#################################################################################################################



#my $strpath = $localdir . "/". $str_file;
my $strpath = $str_file;
#my $bkppath = $localdir . "/". $backup_file;
my $bkppath = $backup_tail;

#check if not working in local directory to save the backup in the same directory than the other files
my @strdirectories = split('/' , $strpath);
my $lengthpath = scalar(@strdirectories);
my @bkpdirectories = split('/', $bkppath);
my $pathlength = scalar(@bkpdirectories);


#print "\n@bkpdirectories\nVS.\n@strdirectories\n\n$pathlength VS. $lengthpath\n";

if ($pathlength==1 && $lengthpath > 1) {
	$backup_file = "$strdirectories[-1]" . "$backup_tail";
	$bkppath = "$str_file" . "$backup_tail";
}
elsif ($pathlength==1 && $lengthpath == 1) {
	$backup_file = "$str_file" . "$backup_tail";
	$bkppath = "$str_file" . "$backup_tail";
}
elsif ($pathlength > 1) {
	$backup_file = "$bkpdirectories[-1]";
	$bkppath = "$backup_tail";
}
else { die "Something wrong with the backup tail ($backup_tail) or the Structure file ($str_file) passed.
For options, usage and other information check the help typing the name of the program version and \"help\" or \"--h\" or so...
\t$program_name -help"}


print "\nBacking up the original structure input file \"$strpath\", saving it as \"$bkppath\"\n\n";

#debug
#die "\nParameters:\n  Input file name:  $vcf_file\n\n";

system("cp $strpath $bkppath");


# Make new locus names from the vcf file
#my $vcfpath = $localdir . "/". $vcf_file;
my $vcfpath = $vcf_file;
print "Processing data in the file \"$vcf_file\"\n";
open my $FILE1, '<', $vcfpath or die "\nUnable to find or open $vcf_file: $!\n";


my @snp_lines = ();
my @newlist = ();
my $k=0;

while (<$FILE1>) {
	chomp;	#clean "end of line" symbols
	
	next if /^(\s*(#.*)?)?$/;   # skip blank lines and comments
	
	my $line = $_;
	$line =~ s/\s+$//;		#clean white tails in lines
	
	my @newline = split('\t', $line);	#split columns as different elements of an array
	
	my $scaffold = $newline[0];
	$scaffold =~ s/\D//g;
	
	my $ref = $newline[2];
	my @refnum = split(':', $ref);
	my $new_name = "$scaffold" . "_" . "$refnum[0]";
	push (@newlist, $new_name);
	$k++;
}
close $FILE1;


print "$k loci names processed\n\n";


# Replace column names from Structure with newlist
open my $FILE2, '<', $strpath or die "\nUnable to find or open $str_file: $!\n";

print "Reading \"$str_file\": ";

my @str_allinfo = ();
my $l=0;

while (<$FILE2>) {
	chomp;	#clean "end of line" symbols
	
	next if /^(\s*(#.*)?)?$/;   # skip blank lines and comments
	
	my $line = $_;
	my $row = $line;
	if ($headers eq "no" || $l >= 1) {push (@str_allinfo, $row);}
	$l++;
}
close $FILE2;

my $samples = $l-1;

print "$samples/2 samples processed.\n\n";

print "Replacing original file\n";
open my $OUT, '>', $strpath or die "\nUnable to create or overwrite $str_file: $!\n";

#Add locus names
print $OUT "\t\t";
foreach (@newlist) {print $OUT "$_\t";} # Print each entry in our array to the file
# Add rest of the info
print $OUT "\n";
foreach (@str_allinfo) {print $OUT "$_\n";} # Print each entry in our array to the file
close $OUT; 

print "Structure file \"$str_file\" has been overwritted using the new locus names\nDone! $program_name finished.\n\n";










